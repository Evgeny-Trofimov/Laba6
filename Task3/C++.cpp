// Подключение стандартной библиотеки ввода-вывода C++
#include <iostream>

// Подключение библиотеки для работы с динамическими массивами (векторами)
#include <vector>

// Подключение библиотеки для форматированного вывода (setw, fixed и др.)
#include <iomanip>

// Подключение математической библиотеки (abs, max и др.)
#include <cmath>

// Использование стандартного пространства имен для упрощения кода
using namespace std;

// Константа для сравнения чисел с плавающей точкой (точность вычислений)
const double EPSILON = 1e-6;

// Функция, реализующая метод Гаусса для решения систем линейных уравнений
vector<double> GaussianElimination(vector<vector<double>> A, vector<double> b) {
    // Получаем размер матрицы (количество уравнений в системе)
    int n = A.size();
    
    // Начало прямого хода метода Гаусса
    for (int i = 0; i < n; i++) {
        // Инициализация переменной для поиска строки с максимальным элементом
        int maxRow = i;
        
        // Поиск строки с максимальным элементом в текущем столбце
        for (int k = i + 1; k < n; k++)
            // Сравнение абсолютных значений элементов
            if (abs(A[k][i]) > abs(A[maxRow][i]))
                maxRow = k;

        // Обмен текущей строки со строкой, содержащей максимальный элемент
        swap(A[i], A[maxRow]);
        // Соответствующий обмен элементов вектора правой части
        swap(b[i], b[maxRow]);
        
        // Исключение переменной из нижележащих строк
        for (int k = i + 1; k < n; k++) {
            // Вычисление множителя для исключения переменной
            double factor = A[k][i] / A[i][i];
            
            // Вычитание текущей строки с множителем из всех нижележащих строк
            for (int j = i; j < n; j++)
                A[k][j] -= factor * A[i][j];
                
            // Аналогичное преобразование вектора правой части    
            b[k] -= factor * b[i];
        }
    }
    
    // Инициализация вектора решений нулями
    vector<double> x(n, 0);
    
    // Обратный ход метода Гаусса (нахождение решений)
    for (int i = n - 1; i >= 0; i--) {
        // Начальное значение берется из правой части
        x[i] = b[i];
        
        // Вычитание уже найденных решений
        for (int j = i + 1; j < n; j++)
            x[i] -= A[i][j] * x[j];
            
        // Деление на диагональный элемент для получения окончательного решения
        x[i] /= A[i][i];
    }
    
    // Возврат вектора решений
    return x;
}

// Функция, реализующая метод Зейделя для решения систем линейных уравнений
vector<double> SeidelMethod(const vector<vector<double>>& A, const vector<double>& b, double epsilon = EPSILON, int maxIterations = 100) {
    // Получаем размер матрицы
    int n = A.size();
    
    // Инициализация вектора текущего приближения нулями
    vector<double> x(n, 0.0);
    
    // Инициализация вектора предыдущего приближения нулями
    vector<double> x_prev(n, 0.0);
    
    // Счетчик итераций
    int iteration = 0;
    
    // Переменная для хранения максимальной ошибки между итерациями
    double error;

    // Основной цикл итерационного процесса
    do {
        // Сохранение предыдущего приближения перед вычислением нового
        x_prev = x;
        
        // Обновление каждой компоненты решения
        for (int i = 0; i < n; i++) {
            // Инициализация суммы для вычисления нового значения
            double sum = 0.0;
            
            // Вычисление суммы произведений коэффициентов и значений переменных
            for (int j = 0; j < n; j++) {
                if (j != i) {
                    // Использование уже обновленных значений для текущей итерации
                    sum += A[i][j] * (j < i ? x[j] : x_prev[j]);
                }
            }
            
            // Вычисление нового значения переменной
            x[i] = (b[i] - sum) / A[i][i];
        }

        // Вычисление максимальной ошибки между текущей и предыдущей итерацией
        error = 0.0;
        for (int i = 0; i < n; i++) {
            error = max(error, abs(x[i] - x_prev[i]));
        }
        
        // Увеличение счетчика итераций
        iteration++;
        
    // Условия продолжения итерационного процесса
    } while (error > epsilon && iteration < maxIterations);

    // Проверка на достижение максимального числа итераций
    if (iteration == maxIterations) {
        // Вывод сообщения о несходимости метода
        cout << "Метод Зейделя не сходится" << endl;
        return x;
    }
    else {
        // Вывод сообщения о успешной сходимости
        cout << "Метод Зейделя сошелся за " << iteration << " итераций\n";
        return x;
    }
}

// Функция для красивого вывода результатов решения
void printResults(const vector<double>& x, const string& methodName) {
    // Вывод заголовка с названием метода решения
    cout << "\nРезультаты решения методом " << methodName << ":\n";
    
    // Отрисовка верхней границы таблицы
    cout << "+-----+-------------+-------------+-------------+-------------+\n";
    
    // Вывод заголовков столбцов таблицы
    cout << "|  N  |     x1      |     x2      |     x3      |     x4      |\n";
    
    // Отрисовка разделительной линии
    cout << "+-----+-------------+-------------+-------------+-------------+\n";
    
    // Вывод значений решений с форматированием (фиксированная точность)
    cout << "|  1  | " << setw(11) << fixed << setprecision(8) << x[0] 
         << " | " << setw(11) << x[1] 
         << " | " << setw(11) << x[2] 
         << " | " << setw(11) << x[3] << " |\n";
         
    // Отрисовка нижней границы таблицы
    cout << "+-----+-------------+-------------+-------------+-------------+\n\n";
}

// Главная функция программы
int main() {
    // Инициализация матрицы коэффициентов системы уравнений
    vector<vector<double>> A = {
        {-18.0,  -0.04,  0.21,  0.91},
        {-0.09,  -1.23,  -0.23, 0.25},
        {-0.13, -0.23,  0.8,   -0.21},
        {-1.04,  -1.31,  0.06,  0.15}
    };

    // Инициализация вектора правых частей системы уравнений
    vector<double> b = {-1.24, -1.04, 2.56, 0.91};

    // Проверка матрицы на диагональное преобладание
    bool isDominant = true;
    
    // Цикл по строкам матрицы
    for (int i = 0; i < 4; i++) {
        // Инициализация суммы абсолютных значений внедиагональных элементов
        double sum = 0.0;
        
        // Цикл по столбцам матрицы
        for (int j = 0; j < 4; j++) {
            // Суммирование элементов не на диагонали
            if (j != i) sum += abs(A[i][j]);
        }
        
        // Проверка условия диагонального преобладания
        if (abs(A[i][i]) <= sum) {
            isDominant = false;
            // Вывод предупреждения для строки, не удовлетворяющей условию
            cout << "Строка " << i+1 << " не удовлетворяет условию диагонального преобладания\n";
        }
    }
    
    // Вывод общего предупреждения, если матрица не имеет диагонального преобладания
    if (!isDominant) {
        cout << "Внимание: матрица не имеет диагонального преобладания!\n";
    }

    // Решение системы методом Гаусса
    vector<double> x_gauss = GaussianElimination(A, b);
    
    // Вывод результатов решения методом Гаусса
    printResults(x_gauss, "Гаусса");

    // Решение системы методом Зейделя
    vector<double> x_seidel = SeidelMethod(A, b);
    
    // Вывод результатов решения методом Зейделя
    printResults(x_seidel, "Зейделя");

    // Завершение программы с кодом 0 (успешное выполнение)
    return 0;
}
